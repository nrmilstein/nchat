{"version":3,"sources":["utils/NchatApi.tsx","chatApp/ChatAppContext.tsx","chatApp/sidebar/SidebarBanner.tsx","chatApp/sidebar/ConversationRow.tsx","chatApp/sidebar/ConversationList.tsx","chatApp/sidebar/Sidebar.tsx","chatApp/contentView/ConversationViewBanner.tsx","chatApp/contentView/MessageView.tsx","misc/LoadingIcon.tsx","chatApp/contentView/MessagesView.tsx","chatApp/contentView/MessageInput.tsx","chatApp/contentView/ConversationView.tsx","chatApp/contentView/ConversationCreatorViewBanner.tsx","chatApp/contentView/ConversationCreatorView.tsx","chatApp/contentView/ContentView.tsx","chatApp/ChatApp.tsx","utils/NchatWebSocket.tsx","chatApp/ChatAppLoader.tsx","accounts/LoginForm.tsx","accounts/SignUpForm.tsx","accounts/AccountsView.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["NchatApi","path","authKey","init","customHeaders","headers","this","appendHeaders","fetch","apiUrl","response","responseClone","clone","json","jsonResponse","ok","status","NchatApiErrorResponse","message","NchatApiError","body","postInit","JSON","stringify","putInit","deleteInit","additionalHeaders","headerKey","hasOwnProperty","Headers","append","Array","isArray","push","Error","captureStackTrace","ChatAppContext","React","createContext","user","id","name","email","SidebarBanner","props","Consumer","context","className","onClick","handleNewConversation","ConversationRow","selected","handleConversationRowClick","conversation","conversationPartner","ConversationList","conversationRows","conversations","map","key","uuid","selectedConversation","Sidebar","ConversationViewBanner","MessageView","senderId","LoadingIcon","MessagesView","SCROLL_TOLERANCE","conversationViewDiv","createRef","scrollToBottom","bind","prevProps","prevState","isScrolledToBottom","messages","ref","isLoading","snapshot","prevMessages","length","node","current","scrollTop","scrollHeight","clientHeight","scrollTo","Component","contextType","MessageInput","state","messageBody","handleChange","handleClickSend","handleKeyDown","event","setState","target","value","trim","handleSendMessage","type","onKeyDown","onChange","autoFocus","placeholder","ConversationView","ConversationCreatorViewBanner","handleEmailChange","conversationCreatorEmail","onBlur","handleBlur","ConversationCreatorView","handleEmailInputBlur","get","userJson","data","ContentView","isConversationCreatorOpen","ChatApp","handleMessageReceived","webSocket","addNotificationListener","isHistoryLoaded","index","findIndex","c","loadingConversations","update","$set","newMessages","uuidv4","sent","updatedConversations","notification","messageJson","conversationJson","newMessage","$push","newConversation","conversationIndex","sendMessage","messageIndex","m","syncedConversations","request","method","sendRequest","contextValue","Provider","close","NchatWebSocket","isAuthMessageSent","requestId","requestPromises","notificationListeners","addEventListener","location","window","url","protocol","host","WebSocket","websocketUrl","Promise","resolve","reject","nchatWebSocket","parse","listeners","listener","getNextId","send","registerPromise","getWebsocketUrl","ChatAppLoader","userPromise","initUser","conversationsPromise","initConversations","createWebSocket","sendAuth","all","LoginForm","password","handleSubmit","preventDefault","authenticateUser","onSubmit","required","to","SignUpForm","requestBody","post","AccountsView","setAuthenticatedUser","navigate","App","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console"],"mappings":"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","file":"static/js/main.2911dddd.chunk.js","sourcesContent":["class NchatApi {\n  static apiUrl = \"/api/v1/\";\n\n  static async fetch<T>(path: string, authKey?: string, init?: RequestInit):\n    Promise<NchatApiSuccessResponse<T>> {\n\n    let customHeaders: { [index: string]: string } = {\n      \"Accept\": \"application/json\",\n    }\n    if (authKey) {\n      customHeaders[\"X-API-KEY\"] = authKey;\n    }\n\n    if (init) {\n      if (init.headers) {\n        this.appendHeaders(init.headers, customHeaders);\n      } else {\n        init.headers = customHeaders;\n      }\n    } else {\n      init = {\n        \"headers\": customHeaders,\n      }\n    }\n\n    const response = await fetch(this.apiUrl + path, init)\n\n    // If we want to pass the response in an error later, we must clone it, because\n    // response.body can only be consumed once.\n    const responseClone = response.clone();\n\n    const jsonResponse = await response.json();\n\n    if (!response.ok || (\"status\" in jsonResponse && jsonResponse.status !== \"success\")) {\n      if (\"status\" in jsonResponse && \"message\" in jsonResponse) {\n        throw new NchatApiErrorResponse(jsonResponse.message, responseClone, jsonResponse);\n      } else if (\"status\" in jsonResponse) {\n        throw new NchatApiErrorResponse(\"Nchat API error.\", responseClone, jsonResponse);\n      } else {\n        throw new NchatApiError(\"Nchat API error.\", responseClone);\n      }\n    }\n\n    if (!(\"status\" in jsonResponse)) {\n      throw new NchatApiError(\"Missing 'status' field in nchat response.\", responseClone);\n    }\n\n    return jsonResponse as NchatApiSuccessResponse<T>;\n  }\n\n  static async get<T>(path: string, authKey?: string, init?: RequestInit):\n    Promise<NchatApiSuccessResponse<T>> {\n    return this.fetch(path, authKey, init);\n  }\n\n  static async post<T>(path: string, body: any, authKey?: string, init?: RequestInit):\n    Promise<NchatApiSuccessResponse<T>> {\n    const postInit = {\n      ...init,\n      \"method\": \"POST\",\n      \"body\": JSON.stringify(body),\n    };\n    return this.fetch<T>(path, authKey, postInit);\n  }\n\n  static async put<T>(path: string, body: any, authKey?: string, init?: RequestInit):\n    Promise<NchatApiSuccessResponse<T>> {\n    const putInit = {\n      ...init,\n      \"method\": \"PUT\",\n      \"body\": JSON.stringify(body),\n    };\n    return this.fetch<T>(path, authKey, putInit);\n  }\n\n  static async delete<T>(path: string, authKey?: string, init?: RequestInit):\n    Promise<NchatApiSuccessResponse<T>> {\n    const deleteInit = {\n      ...init,\n      \"method\": \"DELETE\",\n    };\n    return this.fetch<T>(path, authKey, deleteInit);\n  }\n\n  private static appendHeaders(\n    headers: HeadersInit,\n    additionalHeaders: { [index: string]: string }) {\n    for (const headerKey in additionalHeaders) {\n      if (additionalHeaders.hasOwnProperty(headerKey)) {\n        if (headers instanceof Headers) {\n          headers.append(headerKey, additionalHeaders[headerKey]);\n        } else if (Array.isArray(headers)) {\n          headers.push([headerKey, additionalHeaders[headerKey]]);\n        } else if (typeof headers === 'object') {\n          headers[headerKey] = additionalHeaders[headerKey];\n        }\n      }\n    }\n  }\n}\n\ninterface NchatApiSuccessResponse<T> {\n  status: string,\n  data: T,\n}\n\ninterface NchatApiFailureResponse {\n  status: string,\n  message: string,\n  code: number,\n}\n\nclass NchatApiError extends Error {\n  response: Response;\n  constructor(message: string, response: Response) {\n    super(message);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NchatApiError)\n    }\n    this.response = response;\n  }\n}\n\nclass NchatApiErrorResponse extends NchatApiError {\n  body: NchatApiErrorResponse;\n\n  constructor(message: string, response: Response, body: NchatApiErrorResponse) {\n    super(message, response);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NchatApiErrorResponse)\n    }\n    this.body = body;\n  }\n}\n\nexport default NchatApi;\n","import React from \"react\";\nimport { User } from \"../models/User\";\n\ninterface ChatAppContextType {\n  authKey: string,\n  user: User,\n}\n\nexport const ChatAppContext = React.createContext<ChatAppContextType>({\n  authKey: \"\",\n  user: {\n    id: -1,\n    name: \"\",\n    email: \"\"\n  },\n});\n","import React from 'react';\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport { ChatAppContext } from '../ChatAppContext';\n\nimport \"./SidebarBanner.css\"\n\ninterface SidebarBannerProps extends RouteComponentProps {\n  handleNewConversation: () => void,\n}\n\nfunction SidebarBanner(props: SidebarBannerProps) {\n  return (\n    <ChatAppContext.Consumer>\n      {\n        context => {\n          return (\n            <header className=\"SidebarBanner\">\n              <div className=\"SidebarBanner__userName\">\n                {context.user.name ?? context.user.email}\n              </div>\n              <button className=\"SidebarBanner__plus\" onClick={props.handleNewConversation}>\n                ï¼‹\n              </button>\n            </header>\n          )\n        }\n      }\n    </ChatAppContext.Consumer>\n  );\n}\n\nexport default SidebarBanner;","import React from 'react';\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport { Conversation } from '../../models/Conversation';\n\nimport \"./ConversationRow.css\"\n\ninterface ConversationRowProps extends RouteComponentProps {\n  selected: boolean,\n  conversation: Conversation,\n  handleConversationRowClick: (conversation: Conversation) => void,\n}\n\nfunction ConversationRow(props: ConversationRowProps) {\n  return (\n    <div\n      className={\"ConversationRow\" + (props.selected ? \" ConversationRow--selected\" : \"\")}\n      onClick={() => props.handleConversationRowClick(props.conversation)}>\n      <div className=\"ConversationRow__name\">\n        {props.conversation.conversationPartner.name\n          ?? props.conversation.conversationPartner.email}\n      </div>\n      <div className=\"ConversationRow__preview\"></div>\n    </div>\n  );\n}\n\nexport default ConversationRow;\n","import React from 'react';\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport ConversationRow from './ConversationRow';\nimport { Conversation } from '../../models/Conversation';\n\nimport \"./ConversationList.css\"\n\ninterface ConversationListProps extends RouteComponentProps {\n  conversations: Conversation[],\n  selectedConversation: Conversation | null,\n  handleConversationRowClick: (conversation: Conversation) => void,\n}\n\nfunction ConversationList(props: ConversationListProps) {\n  const conversationRows = props.conversations.map(conversation => {\n    return (\n      <ConversationRow\n        key={conversation.uuid}\n        selected={conversation.uuid === props.selectedConversation?.uuid}\n        conversation={conversation}\n        handleConversationRowClick={props.handleConversationRowClick} />\n    );\n  });\n  return (\n    <div className=\"ConversationList\">\n      {conversationRows}\n    </div>\n  );\n}\n\nexport default ConversationList;\n","import React from 'react';\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport SidebarBanner from './SidebarBanner';\nimport ConversationList from './ConversationList';\nimport { Conversation } from '../../models/Conversation';\n\nimport './Sidebar.css'\n\ninterface SidebarProps extends RouteComponentProps {\n  conversations: Conversation[],\n  selectedConversation: Conversation | null,\n  handleNewConversation: () => void,\n  handleConversationRowClick: (conversation: Conversation) => void,\n}\n\nfunction Sidebar(props: SidebarProps) {\n  return (\n    <nav className=\"Sidebar\">\n      <SidebarBanner handleNewConversation={props.handleNewConversation} />\n      <ConversationList\n        conversations={props.conversations}\n        selectedConversation={props.selectedConversation}\n        handleConversationRowClick={props.handleConversationRowClick} />\n    </nav>\n  );\n}\n\nexport default Sidebar;\n","import React from 'react'\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport { Conversation } from '../../models/Conversation';\n\nimport './ConversationViewBanner.css'\n\ninterface ConversationViewBannerProps extends RouteComponentProps {\n  selectedConversation: Conversation,\n}\n\ninterface ConversationViewBannerState {\n}\n\nfunction ConversationViewBanner(props: ConversationViewBannerProps) {\n  return (\n    <header className=\"ConversationViewBanner\" >\n      {props.selectedConversation.conversationPartner.name\n        ?? props.selectedConversation.conversationPartner.email}\n    </header >\n  );\n}\n\nexport default ConversationViewBanner;","import React from \"react\"\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport { ChatAppContext } from \"../ChatAppContext\";\nimport { Message } from \"../../models/Message\";\n\nimport './MessageView.css'\n\ninterface MessageViewProps extends RouteComponentProps {\n  message: Message,\n}\n\nfunction MessageView(props: MessageViewProps) {\n  return (\n    <ChatAppContext.Consumer>\n      {context =>\n        <div\n          className={\n            \"MessageView\"\n            + (context.user?.id === props.message.senderId\n              ? (props.message.id === null\n                ? \" MessageView--us_unsynced\"\n                : \" MessageView--us_synced\"\n              )\n              : \" MessageView--them\")\n          }>\n          <div className=\"MessageView__messageBody\">\n            {props.message.body}\n          </div>\n        </div >\n      }\n    </ChatAppContext.Consumer >\n  );\n}\n\nexport default MessageView;\n","import React from 'react';\n\nimport \"./LoadingIcon.css\";\n\nfunction LoadingIcon() {\n  return (\n    <div className=\"LoadingIcon\">\n    </div>\n  )\n}\n\nexport default LoadingIcon;","import React from 'react'\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport MessageView from './MessageView';\nimport { Message } from '../../models/Message';\nimport { ChatAppContext } from '../ChatAppContext';\n\nimport './MessagesView.css'\nimport LoadingIcon from '../../misc/LoadingIcon';\n\ninterface MessagesViewProps extends RouteComponentProps {\n  isLoading: boolean,\n  messages: Message[],\n}\n\ninterface MessagesViewState {\n}\n\ninterface MessagesViewSnapshot {\n  isScrolledToBottom: boolean,\n}\n\nclass MessagesView extends React.Component<MessagesViewProps, MessagesViewState> {\n  // Number of pixels chat div can be scrolled above bottom to still be considered at bottom\n  SCROLL_TOLERANCE = 40;\n\n  conversationViewDiv = React.createRef<HTMLDivElement>();\n\n  static contextType = ChatAppContext;\n  context!: React.ContextType<typeof ChatAppContext>\n\n  constructor(props: MessagesViewProps) {\n    super(props);\n    this.scrollToBottom = this.scrollToBottom.bind(this);\n  }\n\n  componentDidMount() {\n    this.scrollToBottom();\n  }\n\n  getSnapshotBeforeUpdate(prevProps: MessagesViewProps, prevState: MessagesViewState):\n    MessagesViewSnapshot {\n    return {\n      isScrolledToBottom: this.isScrolledToBottom()\n    };\n  }\n\n  render() {\n    let messages: JSX.Element[] = this.props.messages.map(message => {\n      return <MessageView key={message.uuid} message={message} />\n    });\n    return (\n      <div className=\"MessagesView\" ref={this.conversationViewDiv}>\n        {this.props.isLoading\n          && <div className=\"MessagesView__loadingIcon\"><LoadingIcon /></div>}\n        {messages}\n      </div>\n    );\n  }\n\n  componentDidUpdate(\n    prevProps: MessagesViewProps,\n    prevState: MessagesViewState,\n    snapshot: MessagesViewSnapshot,\n  ) {\n    const prevMessages = prevProps.messages;\n    const messages = this.props.messages;\n\n    // If there's a new message added\n    if (prevMessages[prevMessages.length - 1]?.uuid !== messages[messages.length - 1]?.uuid) {\n      // Keep us scrolled to the bottom if we're already there, or if the last message\n      // added is from us (i.e. we just sent a message).\n      if (snapshot.isScrolledToBottom\n        || messages[messages.length - 1].senderId === this.context.user.id) {\n        this.scrollToBottom();\n      }\n    }\n  }\n\n  private isScrolledToBottom(): boolean {\n    const node = this.conversationViewDiv.current;\n    if (node === null) {\n      return true;\n    }\n    return node.scrollTop >= (node.scrollHeight - node.clientHeight) - this.SCROLL_TOLERANCE;\n  }\n\n  private scrollToBottom() {\n    const node = this.conversationViewDiv.current;\n    if (node === null) {\n      return;\n    }\n    node.scrollTo(0, node.scrollHeight - node.clientHeight);\n  }\n}\n\nexport default MessagesView;\n","import React, { ChangeEvent, KeyboardEvent } from 'react'\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport './MessageInput.css'\n\ninterface MessageInputProps extends RouteComponentProps {\n  autoFocus: boolean,\n  handleSendMessage: (messageBody: string) => boolean,\n}\n\ninterface MessageInputState {\n  messageBody: string,\n}\n\nclass MessageInput extends React.Component<MessageInputProps, MessageInputState> {\n  state: MessageInputState = {\n    messageBody: \"\",\n  };\n\n  constructor(props: MessageInputProps) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.handleClickSend = this.handleClickSend.bind(this);\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n  }\n\n  handleChange(event: ChangeEvent<HTMLInputElement>) {\n    this.setState({\n      messageBody: event.target.value,\n    });\n  }\n\n  async handleClickSend() {\n    if (this.state.messageBody.trim() === \"\") {\n      return;\n    }\n    const success = this.props.handleSendMessage(this.state.messageBody);\n    if (success) {\n      this.setState({\n        messageBody: \"\",\n      });\n    }\n  }\n\n  handleKeyDown(event: KeyboardEvent<HTMLInputElement>) {\n    if (event.key === \"Enter\") {\n      this.handleClickSend();\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"MessageInput\" >\n        <input\n          name=\"messageBody\"\n          className=\"MessageInput__input\"\n          type=\"text\"\n          value={this.state.messageBody}\n          onKeyDown={this.handleKeyDown}\n          onChange={this.handleChange}\n          autoFocus={this.props.autoFocus}\n          placeholder=\"Type a message\" />\n        <button\n          className=\"MessageInput__button button\"\n          onClick={this.handleClickSend}>\n          Send\n          </button>\n      </div>\n    );\n  }\n}\n\nexport default MessageInput;\n","import React from 'react';\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport { Conversation } from '../../models/Conversation';\nimport ConversationViewBanner from './ConversationViewBanner';\nimport MessagesView from './MessagesView';\nimport MessageInput from './MessageInput';\n\nimport './ConversationView.css'\n\ninterface ConversationViewProps extends RouteComponentProps {\n  selectedConversation: Conversation,\n  handleSendMessage: (messageBody: string) => void,\n}\n\nfunction ConversationView(props: ConversationViewProps) {\n  return (\n    <div className=\"ConversationView\" >\n      <ConversationViewBanner\n        selectedConversation={props.selectedConversation} />\n      <MessagesView\n        isLoading={props.selectedConversation.isLoading}\n        messages={props.selectedConversation.messages} />\n      <MessageInput\n        autoFocus={true}\n        handleSendMessage={\n          (messageBody) => {\n            props.handleSendMessage(messageBody);\n            return true;\n          }\n        } />\n    </div>\n  );\n}\n\nexport default ConversationView","import React, { ChangeEvent, FocusEvent } from 'react';\n\nimport './ConversationCreatorViewBanner.css'\n\ninterface ConversationCreatorViewBannerProps {\n  conversationCreatorEmail: string,\n  handleEmailChange: (email: string) => void,\n  handleBlur: (event: FocusEvent<HTMLInputElement>) => void,\n}\n\ninterface ConversationCreatorViewBannerState {\n}\n\nclass ConversationCreatorViewBanner extends\n  React.Component<ConversationCreatorViewBannerProps, ConversationCreatorViewBannerState> {\n  constructor(props: ConversationCreatorViewBannerProps) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange(event: ChangeEvent<HTMLInputElement>) {\n    this.props.handleEmailChange(event.target.value);\n  }\n\n  render() {\n    return (\n      <header className=\"ConversationCreatorViewBanner\">\n        <label className=\"ConversationCreatorViewBanner__toFieldLabel\">To:\n          <input\n            type=\"text\"\n            className=\"ConversationCreatorViewBanner__input\"\n            placeholder=\"Email\"\n            value={this.props.conversationCreatorEmail}\n            onChange={this.handleChange}\n            autoFocus={true}\n            onBlur={this.props.handleBlur} />\n        </label>\n      </header>\n    );\n  }\n}\n\nexport default ConversationCreatorViewBanner;","import React, { FocusEvent } from 'react';\n\nimport ConversationCreatorViewBanner from './ConversationCreatorViewBanner';\nimport MessageInput from './MessageInput';\nimport { User } from '../../models/User';\nimport NchatApi from '../../utils/NchatApi';\nimport { ChatAppContext } from '../ChatAppContext';\nimport { UserJson } from '../../utils/json/UserJson';\n\nimport './ConversationCreatorView.css';\n\ninterface GetUserResponse {\n  user: UserJson,\n}\n\ninterface ConversationCreatorViewProps {\n  handleSendMessage: (messageBody: string, user?: User) => void,\n}\n\ninterface ConversationCreatorViewState {\n  email: string,\n  conversationPartner: User | null,\n}\n\nclass ConversationCreatorView\n  extends React.Component<ConversationCreatorViewProps, ConversationCreatorViewState> {\n\n  static contextType = ChatAppContext;\n  context!: React.ContextType<typeof ChatAppContext>\n\n  state: ConversationCreatorViewState = {\n    email: \"\",\n    conversationPartner: null,\n  }\n\n  constructor(props: ConversationCreatorViewProps) {\n    super(props);\n    this.handleEmailChange = this.handleEmailChange.bind(this);\n    this.handleSendMessage = this.handleSendMessage.bind(this);\n    this.handleEmailInputBlur = this.handleEmailInputBlur.bind(this);\n  }\n\n  handleEmailChange(email: string) {\n    this.setState({\n      email: email,\n    });\n  }\n\n  handleSendMessage(messageBody: string): boolean {\n    if (this.state.conversationPartner === null) {\n      return false;\n    }\n    this.props.handleSendMessage(messageBody, this.state.conversationPartner);\n    return true;\n  }\n\n  async handleEmailInputBlur(event: FocusEvent<HTMLInputElement>) {\n    const email = this.state.email;\n    try {\n      if (email.trim() === \"\") {\n        throw new Error(\"email is empty.\");\n      }\n\n      const response =\n        await NchatApi.get<GetUserResponse>(\"users/\" + email, this.context.authKey);\n      const userJson = response.data.user;\n\n      this.setState({\n        conversationPartner: {\n          id: userJson.id,\n          email: userJson.email,\n          name: userJson.name,\n        },\n      });\n    } catch (e) {\n      this.setState({\n        conversationPartner: null,\n      });\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"ConversationCreatorView\">\n        <ConversationCreatorViewBanner\n          conversationCreatorEmail={this.state.email}\n          handleEmailChange={this.handleEmailChange}\n          handleBlur={this.handleEmailInputBlur} />\n        <div className=\"ConversationCreatorView__spacer\" />\n        <MessageInput\n          autoFocus={false}\n          handleSendMessage={this.handleSendMessage} />\n      </div>\n    )\n  }\n}\n\nexport default ConversationCreatorView;","import React from 'react';\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport { Conversation } from '../../models/Conversation';\nimport ConversationView from './ConversationView';\nimport ConversationCreatorView from './ConversationCreatorView';\nimport { User } from '../../models/User';\n\nimport \"./ContentView.css\"\n\ninterface ContentViewProps extends RouteComponentProps {\n  isConversationCreatorOpen: boolean,\n  selectedConversation: Conversation | null,\n  handleSendMessage: (messageBody: string, user?: User) => void,\n}\n\nfunction ContentView(props: ContentViewProps) {\n  return (\n    <main className=\"ContentView\" >\n      {\n        props.isConversationCreatorOpen\n          ?\n          <ConversationCreatorView\n            handleSendMessage={props.handleSendMessage} />\n          :\n          props.selectedConversation !== null\n          && <ConversationView\n            selectedConversation={props.selectedConversation}\n            handleSendMessage={props.handleSendMessage}\n            key={props.selectedConversation?.uuid} />\n      }\n    </main>\n  )\n}\n\nexport default ContentView;\n","import React from 'react';\nimport { RouteComponentProps } from '@reach/router';\nimport { v4 as uuidv4 } from 'uuid';\nimport update from 'immutability-helper';\n\nimport NchatApi from '../utils/NchatApi';\nimport Sidebar from './sidebar/Sidebar'\nimport ContentView from './contentView/ContentView'\nimport { User } from '../models/User';\nimport { Conversation } from '../models/Conversation';\nimport { Message } from '../models/Message';\nimport { ConversationJson } from '../utils/json/ConversationJson';\nimport { MessageJson } from '../utils/json/MessageJson';\nimport { ChatAppContext } from './ChatAppContext';\nimport NchatWebSocket, { WSNotification, WSRequest, WSSuccessResponse }\n  from '../utils/NchatWebSocket';\n\nimport './ChatApp.css';\n\ninterface GetConversationResponse {\n  conversation: ConversationJson,\n}\n\ninterface WSMessageNotificationData {\n  message: MessageJson,\n  conversation: ConversationJson,\n}\n\ninterface WSMessageRequestData {\n  email: string,\n  body: string,\n}\n\ninterface WSMessageSuccessResponseData {\n  message: MessageJson,\n  conversation: ConversationJson,\n}\n\ninterface WSMessageErrorResponseData {\n}\n\ninterface ChatAppProps extends RouteComponentProps {\n  authKey: string,\n  user: User,\n  conversations: Conversation[],\n  webSocket: NchatWebSocket,\n}\n\ninterface ChatAppState {\n  conversations: Conversation[],\n  selectedConversation: Conversation | null,\n  isConversationCreatorOpen: boolean,\n}\n\nclass ChatApp extends React.Component<ChatAppProps, ChatAppState> {\n  state: ChatAppState = {\n    conversations: this.props.conversations,\n    selectedConversation: null,\n    isConversationCreatorOpen: false,\n  }\n\n  constructor(props: ChatAppProps) {\n    super(props);\n    this.handleMessageReceived = this.handleMessageReceived.bind(this);\n    this.handleNewConversation = this.handleNewConversation.bind(this);\n    this.handleConversationRowClick = this.handleConversationRowClick.bind(this);\n    this.handleSendMessage = this.handleSendMessage.bind(this);\n  }\n\n  componentDidMount() {\n    this.props.webSocket.addNotificationListener(\"newMessage\", this.handleMessageReceived);\n  }\n\n  handleNewConversation() {\n    this.setState({\n      selectedConversation: null,\n      isConversationCreatorOpen: true,\n    });\n  }\n\n  async handleConversationRowClick(conversation: Conversation) {\n    if (conversation.uuid === this.state.selectedConversation?.uuid) {\n      return;\n    }\n\n    this.setState({\n      isConversationCreatorOpen: false,\n    });\n\n    if (!conversation.isHistoryLoaded && !conversation.isLoading) {\n      let index = this.state.conversations.findIndex(c => c.uuid === conversation.uuid);\n      const loadingConversations = update(this.state.conversations,\n        {\n          [index]: {\n            isLoading: {\n              $set: true,\n            },\n          },\n        },\n      );\n\n      this.setState({\n        conversations: loadingConversations,\n        selectedConversation: loadingConversations[index],\n      });\n\n      const response = await NchatApi.get<GetConversationResponse>(\n        \"conversations/\" + conversation.id, this.props.authKey);\n      const newMessages = response.data.conversation.messages.map(message => {\n        return {\n          uuid: uuidv4(),\n          id: message.id,\n          senderId: message.senderId,\n          body: message.body,\n          sent: message.sent,\n        }\n      });\n\n      index = this.state.conversations.findIndex(c => c.uuid === conversation.uuid);\n      const updatedConversations = update(this.state.conversations,\n        {\n          [index]: {\n            messages: {\n              $set: newMessages,\n            },\n            isLoading: {\n              $set: false,\n            },\n            isHistoryLoaded: {\n              $set: true,\n            }\n          }\n        },\n      );\n\n      this.setState({\n        conversations: updatedConversations,\n        selectedConversation: updatedConversations[index],\n      });\n    } else {\n      this.setState({\n        selectedConversation: conversation,\n      });\n    }\n  }\n\n  handleMessageReceived(notification: WSNotification<WSMessageNotificationData>) {\n    const messageJson = notification.data.message;\n    const conversationJson = notification.data.conversation;\n\n    const newMessage: Message = {\n      uuid: uuidv4(),\n      id: messageJson.id,\n      body: messageJson.body,\n      senderId: messageJson.senderId,\n      sent: messageJson.sent,\n    };\n\n    const index = this.state.conversations.findIndex(c => c.id === conversationJson.id);\n    if (index === -1) {\n      const newConversation: Conversation = {\n        uuid: uuidv4(),\n        id: conversationJson.id,\n        conversationPartner: {\n          id: conversationJson.conversationPartner.id,\n          email: conversationJson.conversationPartner.email,\n          name: conversationJson.conversationPartner.name,\n        },\n        messages: [newMessage],\n        isHistoryLoaded: true,\n        isLoading: false,\n      };\n      const updatedConversations = [\n        newConversation,\n        ...this.state.conversations,\n      ];\n      this.setState({\n        conversations: updatedConversations,\n      });\n    } else {\n      const updatedConversations = update(this.state.conversations,\n        {\n          [index]: {\n            messages: {\n              $push: [newMessage]\n            },\n          },\n        },\n      );\n      this.setState({\n        conversations: updatedConversations,\n      });\n      if (this.state.selectedConversation?.uuid === updatedConversations[index].uuid) {\n        this.setState({\n          selectedConversation: updatedConversations[index],\n        });\n      };\n    }\n  }\n\n  async handleSendMessage(messageBody: string, conversationPartner?: User) {\n    const newMessage: Message = {\n      uuid: uuidv4(),\n      id: null,\n      senderId: this.props.user.id,\n      body: messageBody,\n      sent: null,\n    }\n\n    let selectedConversation: Conversation | null;\n\n    if (this.state.isConversationCreatorOpen && conversationPartner) {\n      const newConversation: Conversation = {\n        uuid: uuidv4(),\n        id: null,\n        conversationPartner: conversationPartner,\n        isHistoryLoaded: true,\n        isLoading: false,\n        messages: [newMessage],\n      };\n\n      this.setState((state, props) => {\n        const updatedConversations = [\n          newConversation,\n          ...state.conversations,\n        ];\n        return {\n          conversations: updatedConversations,\n          selectedConversation: newConversation,\n          isConversationCreatorOpen: false,\n        };\n      });\n\n      selectedConversation = newConversation;\n    } else {\n      selectedConversation = this.state.selectedConversation;\n\n      if (selectedConversation === null) {\n        return;\n      }\n\n      const conversationIndex = this.state.conversations.findIndex(c => {\n        return c.uuid === selectedConversation?.uuid\n      });\n      const updatedConversations = update(this.state.conversations,\n        {\n          [conversationIndex]: {\n            messages: {\n              $push: [newMessage],\n            },\n          },\n        },\n      );\n\n      this.setState({\n        conversations: updatedConversations,\n        selectedConversation: updatedConversations[conversationIndex],\n      });\n    }\n\n    const response = await this.sendMessage(\n      selectedConversation.conversationPartner.email, messageBody);\n\n\n    this.setState((state, props) => {\n      const conversationIndex = state.conversations.findIndex(c => {\n        return c.uuid === selectedConversation?.uuid\n      });\n      const messageIndex = state.conversations[conversationIndex].messages.findIndex(m => {\n        return m.uuid === newMessage.uuid;\n      });\n\n      const syncedConversations = update(state.conversations,\n        {\n          [conversationIndex]: {\n            id: {\n              $set: response.data.conversation.id,\n            },\n            messages: {\n              [messageIndex]: {\n                id: {\n                  $set: response.data.message.id\n                },\n              },\n            },\n          },\n        },\n      );\n\n      return {\n        conversations: syncedConversations,\n        selectedConversation: syncedConversations[conversationIndex],\n      };\n    });\n  }\n\n  private sendMessage(email: string, body: string):\n    Promise<WSSuccessResponse<WSMessageSuccessResponseData>> {\n    const request: WSRequest<WSMessageRequestData> = {\n      type: \"request\",\n      method: \"sendMessage\",\n      data: {\n        email: email,\n        body: body,\n      },\n    };\n    return this.props.webSocket.sendRequest(request);\n  }\n\n  render() {\n    const contextValue = {\n      authKey: this.props.authKey,\n      user: this.props.user,\n    }\n    return (\n      <div className=\"ChatApp\">\n        <ChatAppContext.Provider value={contextValue}>\n          <Sidebar\n            conversations={this.state.conversations}\n            selectedConversation={this.state.selectedConversation}\n            handleConversationRowClick={this.handleConversationRowClick}\n            handleNewConversation={this.handleNewConversation} />\n          <ContentView\n            isConversationCreatorOpen={this.state.isConversationCreatorOpen}\n            handleSendMessage={this.handleSendMessage}\n            selectedConversation={this.state.selectedConversation} />\n        </ChatAppContext.Provider>\n      </div >\n    );\n  }\n\n  componentWillUnmount() {\n    this.props.webSocket.close();\n  }\n}\n\nexport default ChatApp;\n","export interface WSNotification<T> {\n  type: \"notification\",\n  method: string,\n  data: T,\n}\n\nexport interface WSRequest<T> {\n  id?: number,\n  type: \"request\",\n  method: string,\n  data: T,\n}\n\nexport interface WSSuccessResponse<T> {\n  id: number,\n  type: \"response\",\n  status: \"success\",\n  data: T,\n}\n\nexport interface WSErrorResponse<T> {\n  id: number,\n  type: \"response\",\n  status: \"error\",\n  code: number,\n  message: string,\n  data: T,\n}\n\ntype NotificationListener = (notification: WSNotification<any>) => void\ninterface NotificationListeners {\n  [index: string]: NotificationListener[]\n}\n\ntype PromiseResolveFunc = (value: WSSuccessResponse<any>) => void;\ntype PromiseRejectFunc = (reason: WSErrorResponse<any>) => void;\ntype PromiseCallbacks = {\n  resolve: PromiseResolveFunc,\n  reject: PromiseRejectFunc,\n}\n\nclass NchatWebSocket {\n  static websocketUrl = NchatWebSocket.getWebsocketUrl();\n\n  webSocket: WebSocket;\n  isAuthMessageSent = false;\n  requestId = 0;\n  requestPromises: PromiseCallbacks[] = [];\n  notificationListeners: NotificationListeners = {};\n\n  static getWebsocketUrl(): string {\n    let location = window.location;\n    let url = (location.protocol === \"https:\" ? \"wss:\" : \"ws:\");\n    url += \"//\" + location.host + \"/api/v1/chat\";\n    return url;\n  }\n\n  static createWebSocket(): Promise<NchatWebSocket> {\n    const webSocket = new WebSocket(this.websocketUrl, \"nchat\");\n    return new Promise((resolve, reject) => {\n      webSocket.addEventListener(\"open\", (event: Event) => {\n        const nchatWebSocket = new NchatWebSocket(webSocket);\n        resolve(nchatWebSocket);\n      })\n      webSocket.addEventListener(\"error\", (event: Event) => {\n        reject(event);\n      })\n    });\n  }\n\n  constructor(webSocket: WebSocket) {\n    this.handleMessageReceived = this.handleMessageReceived.bind(this);\n    this.webSocket = webSocket;\n    this.webSocket.addEventListener(\"message\", this.handleMessageReceived);\n  }\n\n  handleMessageReceived(event: MessageEvent) {\n    const data: WSNotification<any> | WSSuccessResponse<any> | WSErrorResponse<any> =\n      JSON.parse(event.data);\n    if (data.type === \"response\") {\n      if (data.status === \"success\") {\n        this.requestPromises[data.id].resolve(data);\n      } else {\n        this.requestPromises[data.id].reject(data);\n      }\n    } else if (data.type === \"notification\") {\n      const listeners = this.notificationListeners[data.method];\n      if (typeof listeners !== \"undefined\") {\n        for (const listener of listeners) {\n          listener(data);\n        }\n      }\n    }\n  }\n\n  addNotificationListener(method: string, listener: (notification: WSNotification<any>) => void) {\n    if (this.notificationListeners.hasOwnProperty(method)) {\n      this.notificationListeners[method]?.push(listener);\n    } else {\n      this.notificationListeners[method] = [listener];\n    }\n  }\n\n  sendRequest<T, S>(request: WSRequest<T>):\n    Promise<WSSuccessResponse<S>> {\n    const id = this.getNextId();\n    request.id = id;\n\n    this.webSocket.send(JSON.stringify(request));\n\n    return new Promise((resolve, reject) => {\n      this.registerPromise(id, resolve, reject);\n    });\n  }\n\n  close() {\n    this.webSocket.close();\n  }\n\n  private registerPromise(id: number, resolve: PromiseResolveFunc, reject: PromiseRejectFunc) {\n    this.requestPromises[id] = {\n      resolve: resolve,\n      reject: reject\n    };\n  }\n\n  private getNextId(): number {\n    return this.requestId++;\n  }\n}\n\nexport default NchatWebSocket;","import React from 'react';\nimport { RouteComponentProps } from '@reach/router';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport ChatApp from './ChatApp';\nimport { Conversation } from '../models/Conversation';\nimport { ConversationStubJson } from '../utils/json/ConversationJson';\nimport { User } from '../models/User';\nimport { UserJson } from '../utils/json/UserJson';\nimport NchatApi from '../utils/NchatApi';\nimport NchatWebSocket, { WSRequest, WSSuccessResponse } from '../utils/NchatWebSocket';\n\nimport \"./ChatAppLoader.css\";\nimport LoadingIcon from '../misc/LoadingIcon';\n\ninterface GetAuthenticateResponse {\n  user: UserJson,\n}\n\ninterface GetConversationsResponse {\n  conversations: ConversationStubJson[];\n}\n\ninterface WSAuthRequestData {\n  authKey: string,\n}\n\ninterface WSAuthResponseData {\n}\n\ninterface ChatAppLoaderProps extends RouteComponentProps {\n  authKey: string,\n  user: User | null,\n}\n\ninterface ChatAppLoaderState {\n  user: User | null,\n  conversations: Conversation[] | null,\n  webSocket: NchatWebSocket | null,\n}\n\nclass ChatAppLoader extends React.Component<ChatAppLoaderProps, ChatAppLoaderState> {\n  state: ChatAppLoaderState = {\n    user: this.props.user,\n    conversations: null,\n    webSocket: null,\n  }\n\n  async componentDidMount() {\n    const userPromise = this.state.user === null\n      ? Promise.resolve(this.state.user)\n      : this.initUser();\n    const conversationsPromise = this.initConversations();\n\n    const webSocket = await NchatWebSocket.createWebSocket();\n    const authResponse = await this.sendAuth(webSocket);\n    if (authResponse.status !== \"success\") {\n      throw new Error(\"Could not connect to webSocket.\")\n    }\n\n    const [user, conversations] = await Promise.all([userPromise, conversationsPromise]);\n\n    this.setState({\n      user: user,\n      conversations: conversations,\n      webSocket: webSocket,\n    })\n  }\n\n  async initUser(): Promise<User> {\n    const response =\n      await NchatApi.get<GetAuthenticateResponse>(\"authenticate\", this.props.authKey);\n    const user: User = {\n      id: response.data.user.id,\n      name: response.data.user.name,\n      email: response.data.user.email,\n    }\n    return user;\n  }\n\n  async initConversations(): Promise<Conversation[]> {\n    const response =\n      await NchatApi.get<GetConversationsResponse>(\"conversations\", this.props.authKey);\n\n    const conversations = response.data.conversations.map(conversation => {\n      return {\n        uuid: uuidv4(),\n        id: conversation.id,\n        conversationPartner: {\n          id: conversation.conversationPartner.id,\n          email: conversation.conversationPartner.email,\n          name: conversation.conversationPartner.name,\n        },\n        messages: [],\n        isHistoryLoaded: false,\n        isLoading: false,\n      };\n    });\n    return conversations;\n  }\n\n  private sendAuth(webSocket: NchatWebSocket):\n    Promise<WSSuccessResponse<WSAuthResponseData>> {\n    const request: WSRequest<WSAuthRequestData> = {\n      type: \"request\",\n      method: \"authorize\",\n      data: {\n        authKey: this.props.authKey,\n      },\n    };\n\n    return webSocket.sendRequest(request);\n  }\n\n  render() {\n    return (\n      <div className=\"ChatAppLoader\">\n        {\n          this.state.user && this.state.conversations && this.state.webSocket\n            ?\n            <ChatApp\n              authKey={this.props.authKey}\n              user={this.state.user}\n              webSocket={this.state.webSocket}\n              conversations={this.state.conversations} />\n            :\n            <div className=\"ChatAppLoader__loading\">\n              <LoadingIcon />\n            </div>\n        }\n      </div>\n    );\n  }\n}\n\nexport default ChatAppLoader","import React, { ChangeEvent, FormEvent } from 'react';\nimport { RouteComponentProps } from '@reach/router';\nimport { Link } from \"@reach/router\";\n\nimport './LoginForm.css';\n\ninterface LoginFormProps extends RouteComponentProps {\n  authenticateUser: (email: string, password: string) => void,\n};\n\ninterface LoginFormState {\n  email: string,\n  password: string,\n}\n\nclass LoginForm extends React.Component<LoginFormProps, LoginFormState> {\n  state: LoginFormState = {\n    email: '',\n    password: '',\n  };\n\n  constructor(props: LoginFormProps) {\n    super(props);\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event: ChangeEvent<HTMLInputElement>) {\n    this.setState({\n      [event.target.name]: event.target.value,\n    } as Pick<LoginFormState, keyof LoginFormState>);\n  }\n\n  async handleSubmit(event: FormEvent<HTMLFormElement>) {\n    event.preventDefault();\n\n    this.props.authenticateUser(this.state.email, this.state.password);\n  }\n\n  render() {\n    return (\n      <div className=\"LoginForm\" >\n        <h1>Login</h1>\n        <form onSubmit={this.handleSubmit}>\n          <p><input className=\"textInput\" name=\"email\" type=\"text\" placeholder=\"Email\"\n            value={this.state.email} onChange={this.handleChange} required={true}\n            autoFocus={true} /></p>\n          <p><input className=\"textInput\" name=\"password\" type=\"password\" placeholder=\"Password\"\n            value={this.state.password} onChange={this.handleChange} required={true} /></p>\n          <p><input className=\"button\" type=\"submit\" value=\"Login\" /></p>\n        </form>\n        <div className=\"LoginForm__signUpMessage\">\n          Don't have an account? <Link to=\"../signup\">Sign up</Link>\n        </div>\n      </div >\n    );\n  }\n}\n\nexport default LoginForm;\n","import React, { ChangeEvent, FormEvent } from 'react';\nimport { RouteComponentProps } from '@reach/router';\nimport { Link } from \"@reach/router\";\n\nimport NchatApi from '../utils/NchatApi';\n\nimport './SignUpForm.css';\n\ninterface SignUpFormProps extends RouteComponentProps {\n  authenticateUser: (email: string, password: string) => void,\n};\n\ninterface SignUpFormState {\n  name: string,\n  email: string,\n  password: string,\n}\n\nclass SignUpForm extends React.Component<SignUpFormProps, SignUpFormState> {\n  state: SignUpFormState = {\n    \"name\": \"\",\n    \"email\": \"\",\n    \"password\": \"\",\n  };\n\n  constructor(props: SignUpFormProps) {\n    super(props);\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event: ChangeEvent<HTMLInputElement>) {\n    this.setState({\n      [event.target.name]: event.target.value,\n    } as Pick<SignUpFormState, keyof SignUpFormState>)\n  }\n\n  async handleSubmit(event: FormEvent<HTMLFormElement>) {\n    event.preventDefault();\n\n    const requestBody = {\n      \"name\": this.state.name,\n      \"email\": this.state.email,\n      \"password\": this.state.password,\n    }\n\n    // try {\n    const response = await NchatApi.post(\"users\", requestBody);\n    this.props.authenticateUser(this.state.email, this.state.password);\n\n    // } catch (error) {\n    //   throw error;\n    // }\n  }\n\n  render() {\n    return (\n      <div className=\"SignUpForm\" >\n        <h1>Sign up</h1>\n        <form onSubmit={this.handleSubmit}>\n          <p><input className=\"textInput\" name=\"name\" type=\"text\" placeholder=\"Display name\"\n            value={this.state.name} onChange={this.handleChange} required={true}\n            autoFocus={true} /></p>\n          <p><input className=\"textInput\" name=\"email\" type=\"text\" placeholder=\"Email\"\n            value={this.state.email} onChange={this.handleChange} required={true} /></p>\n          <p><input className=\"textInput\" name=\"password\" type=\"password\" placeholder=\"Password\"\n            value={this.state.password} onChange={this.handleChange} required={true} /></p>\n          <p><input className=\"button\" type=\"submit\" value=\"Sign up\" /></p>\n        </form>\n        <div className=\"SignUpForm__loginMessage\">\n          Already have an account? <Link to=\"../login\">Login</Link>\n        </div>\n      </div >\n    );\n  }\n}\n\nexport default SignUpForm;\n","import React from 'react';\nimport { RouteComponentProps } from '@reach/router';\nimport { Router, navigate } from \"@reach/router\";\n\nimport LoginForm from './LoginForm';\nimport SignUpForm from './SignUpForm';\nimport NchatApi from '../utils/NchatApi';\nimport { UserJson } from '../utils/json/UserJson';\n\nimport './AccountsView.css'\nimport { User } from '../models/User';\n\ninterface AccountsViewProps extends RouteComponentProps {\n  setAuthenticatedUser: (authKey: string, user: User) => void;\n}\n\ninterface AccountsViewState {\n}\n\ninterface PostAuthenticateResponse {\n  authKey: string,\n  user: UserJson,\n}\n\nclass AccountsView extends React.Component<AccountsViewProps, AccountsViewState> {\n  constructor(props: AccountsViewProps) {\n    super(props);\n\n    this.authenticateUser = this.authenticateUser.bind(this);\n  }\n\n  async authenticateUser(email: string, password: string) {\n    const requestBody = {\n      \"email\": email,\n      \"password\": password,\n    }\n\n    // try {\n    const response = await NchatApi.post<PostAuthenticateResponse>(\"authenticate\", requestBody);\n\n    const authKey = response.data.authKey;\n    const user: User = {\n      id: response.data.user.id,\n      email: response.data.user.email,\n      name: response.data.user.name,\n    }\n    this.props.setAuthenticatedUser(authKey, user);\n    // } catch (error) {\n    //   throw error;\n    // }\n    navigate(\"/\");\n  }\n\n  render() {\n    return (\n      <main className=\"AccountsView\">\n        <Router>\n          <LoginForm path=\"login\" authenticateUser={this.authenticateUser} />\n          <SignUpForm path=\"signup\" authenticateUser={this.authenticateUser} />\n        </Router>\n      </main>\n    );\n  }\n}\n\nexport default AccountsView;","import React from 'react';\nimport { Router, RouteComponentProps, navigate } from \"@reach/router\";\n\nimport ChatAppLoader from './chatApp/ChatAppLoader';\nimport AccountsView from './accounts/AccountsView';\nimport { User } from './models/User'\n\nimport './App.css';\n\ninterface AppState {\n  authKey: string | null,\n  user: User | null,\n}\n\nclass App extends React.Component<{}, AppState> {\n  state: AppState = {\n    authKey: null,\n    user: null,\n  };\n\n  constructor(props: RouteComponentProps) {\n    super(props);\n\n    this.setAuthenticatedUser = this.setAuthenticatedUser.bind(this);\n  }\n\n  componentDidMount() {\n    if (this.state.authKey === null) {\n      navigate('/accounts/login');\n    }\n  }\n\n  setAuthenticatedUser(authKey: string, user: User) {\n    this.setState({\n      \"authKey\": authKey,\n      \"user\": user,\n    })\n  }\n\n  render() {\n    return (\n      <Router className=\"Router\">\n        {this.state.authKey !== null &&\n          <ChatAppLoader path=\"/\"\n            authKey={this.state.authKey}\n            user={this.state.user}\n            key={this.state.user?.id} />}\n        <AccountsView path=\"accounts/*\" setAuthenticatedUser={this.setAuthenticatedUser} />\n      </Router >\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './common.css';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}