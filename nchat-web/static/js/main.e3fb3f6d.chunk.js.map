{"version":3,"sources":["utils/NchatApi.tsx","chatApp/ChatAppContext.tsx","chatApp/sidebar/SidebarBanner.tsx","chatApp/sidebar/ConversationRow.tsx","chatApp/sidebar/ConversationList.tsx","chatApp/sidebar/Sidebar.tsx","chatApp/contentView/ConversationViewBanner.tsx","chatApp/contentView/MessageView.tsx","misc/LoadingIcon.tsx","chatApp/contentView/MessagesView.tsx","chatApp/contentView/MessageInput.tsx","chatApp/contentView/ConversationView.tsx","chatApp/contentView/ConversationCreatorViewBanner.tsx","chatApp/contentView/ConversationCreatorView.tsx","chatApp/contentView/ContentView.tsx","chatApp/ChatApp.tsx","utils/NchatWebSocket.tsx","chatApp/ChatAppLoader.tsx","accounts/LoginForm.tsx","accounts/SignUpForm.tsx","accounts/AccountsView.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["NchatApi","path","authKey","init","customHeaders","headers","this","appendHeaders","fetch","apiUrl","response","responseClone","clone","json","jsonResponse","ok","status","NchatApiErrorResponse","message","NchatApiError","body","postInit","JSON","stringify","putInit","deleteInit","additionalHeaders","headerKey","hasOwnProperty","Headers","append","Array","isArray","push","Error","captureStackTrace","ChatAppContext","React","createContext","user","id","name","username","SidebarBanner","props","Consumer","context","className","onClick","handleNewConversation","ConversationRow","selected","handleConversationRowClick","conversation","conversationPartner","ConversationList","conversationRows","conversations","map","key","uuid","selectedConversation","Sidebar","ConversationViewBanner","MessageView","senderId","LoadingIcon","style","width","height","MessagesView","SCROLL_TOLERANCE","conversationViewDiv","createRef","scrollToBottom","bind","prevProps","prevState","isScrolledToBottom","messages","ref","isLoading","snapshot","prevMessages","length","node","current","scrollTop","scrollHeight","clientHeight","scrollTo","Component","contextType","MessageInput","state","messageBody","handleChange","handleClickSend","handleKeyDown","event","setState","target","value","trim","handleSendMessage","type","onKeyDown","onChange","autoFocus","placeholder","disabled","ConversationView","ConversationCreatorViewBannerStatus","ConversationCreatorViewBanner","toSpan","Empty","Loading","Ok","htmlFor","conversationCreatorUsername","onBlur","handleBlur","ConversationCreatorView","usernameInputStatus","handleUsernameChange","handleUsernameInputBlur","getConversationPartner","get","userJson","data","ContentView","isConversationCreatorOpen","ChatApp","handleMessageReceived","webSocket","addNotificationListener","isHistoryLoaded","index","findIndex","c","loadingConversations","update","$set","newMessages","uuidv4","sent","updatedConversations","notification","messageJson","conversationJson","newMessage","$push","newConversation","conversationIndex","sendMessage","messageIndex","m","syncedConversations","request","method","sendRequest","contextValue","Provider","close","NchatWebSocket","isAuthMessageSent","requestId","requestPromises","notificationListeners","addEventListener","location","window","url","protocol","host","WebSocket","websocketUrl","Promise","resolve","reject","nchatWebSocket","parse","listeners","listener","getNextId","send","registerPromise","getWebsocketUrl","ChatAppLoader","userPromise","initUser","conversationsPromise","initConversations","createWebSocket","sendAuth","all","LoginForm","password","handleSubmit","preventDefault","authenticateUser","onSubmit","required","to","SignUpForm","requestBody","post","AccountsView","setAuthenticatedUser","navigate","App","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console"],"mappings":"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","file":"static/js/main.e3fb3f6d.chunk.js","sourcesContent":["class NchatApi {\n  static apiUrl = \"/api/v1/\";\n\n  static async fetch<T>(path: string, authKey?: string, init?: RequestInit):\n    Promise<NchatApiSuccessResponse<T>> {\n\n    let customHeaders: { [index: string]: string } = {\n      \"Accept\": \"application/json\",\n    }\n    if (authKey) {\n      customHeaders[\"X-API-KEY\"] = authKey;\n    }\n\n    if (init) {\n      if (init.headers) {\n        this.appendHeaders(init.headers, customHeaders);\n      } else {\n        init.headers = customHeaders;\n      }\n    } else {\n      init = {\n        \"headers\": customHeaders,\n      }\n    }\n\n    const response = await fetch(this.apiUrl + path, init)\n\n    // If we want to pass the response in an error later, we must clone it, because\n    // response.body can only be consumed once.\n    const responseClone = response.clone();\n\n    const jsonResponse = await response.json();\n\n    if (!response.ok || (\"status\" in jsonResponse && jsonResponse.status !== \"success\")) {\n      if (\"status\" in jsonResponse && \"message\" in jsonResponse) {\n        throw new NchatApiErrorResponse(jsonResponse.message, responseClone, jsonResponse);\n      } else if (\"status\" in jsonResponse) {\n        throw new NchatApiErrorResponse(\"Nchat API error.\", responseClone, jsonResponse);\n      } else {\n        throw new NchatApiError(\"Nchat API error.\", responseClone);\n      }\n    }\n\n    if (!(\"status\" in jsonResponse)) {\n      throw new NchatApiError(\"Missing 'status' field in nchat response.\", responseClone);\n    }\n\n    return jsonResponse as NchatApiSuccessResponse<T>;\n  }\n\n  static async get<T>(path: string, authKey?: string, init?: RequestInit):\n    Promise<NchatApiSuccessResponse<T>> {\n    return this.fetch(path, authKey, init);\n  }\n\n  static async post<T>(path: string, body: any, authKey?: string, init?: RequestInit):\n    Promise<NchatApiSuccessResponse<T>> {\n    const postInit = {\n      ...init,\n      \"method\": \"POST\",\n      \"body\": JSON.stringify(body),\n    };\n    return this.fetch<T>(path, authKey, postInit);\n  }\n\n  static async put<T>(path: string, body: any, authKey?: string, init?: RequestInit):\n    Promise<NchatApiSuccessResponse<T>> {\n    const putInit = {\n      ...init,\n      \"method\": \"PUT\",\n      \"body\": JSON.stringify(body),\n    };\n    return this.fetch<T>(path, authKey, putInit);\n  }\n\n  static async delete<T>(path: string, authKey?: string, init?: RequestInit):\n    Promise<NchatApiSuccessResponse<T>> {\n    const deleteInit = {\n      ...init,\n      \"method\": \"DELETE\",\n    };\n    return this.fetch<T>(path, authKey, deleteInit);\n  }\n\n  private static appendHeaders(\n    headers: HeadersInit,\n    additionalHeaders: { [index: string]: string }) {\n    for (const headerKey in additionalHeaders) {\n      if (additionalHeaders.hasOwnProperty(headerKey)) {\n        if (headers instanceof Headers) {\n          headers.append(headerKey, additionalHeaders[headerKey]);\n        } else if (Array.isArray(headers)) {\n          headers.push([headerKey, additionalHeaders[headerKey]]);\n        } else if (typeof headers === 'object') {\n          headers[headerKey] = additionalHeaders[headerKey];\n        }\n      }\n    }\n  }\n}\n\ninterface NchatApiSuccessResponse<T> {\n  status: string,\n  data: T,\n}\n\ninterface NchatApiFailureResponse {\n  status: string,\n  message: string,\n  code: number,\n}\n\nclass NchatApiError extends Error {\n  response: Response;\n  constructor(message: string, response: Response) {\n    super(message);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NchatApiError)\n    }\n    this.response = response;\n  }\n}\n\nclass NchatApiErrorResponse extends NchatApiError {\n  body: NchatApiErrorResponse;\n\n  constructor(message: string, response: Response, body: NchatApiErrorResponse) {\n    super(message, response);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NchatApiErrorResponse)\n    }\n    this.body = body;\n  }\n}\n\nexport default NchatApi;\n","import React from \"react\";\nimport { User } from \"../models/User\";\n\ninterface ChatAppContextType {\n  authKey: string,\n  user: User,\n}\n\nexport const ChatAppContext = React.createContext<ChatAppContextType>({\n  authKey: \"\",\n  user: {\n    id: -1,\n    name: \"\",\n    username: \"\"\n  },\n});\n","import React from 'react';\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport { ChatAppContext } from '../ChatAppContext';\n\nimport \"./SidebarBanner.css\"\n\ninterface SidebarBannerProps extends RouteComponentProps {\n  handleNewConversation: () => void,\n}\n\nfunction SidebarBanner(props: SidebarBannerProps) {\n  return (\n    <ChatAppContext.Consumer>\n      {\n        context => {\n          return (\n            <header className=\"SidebarBanner\">\n              <div className=\"SidebarBanner__userName\">\n                {context.user.name ?? context.user.username}\n              </div>\n              <button className=\"SidebarBanner__plus\" onClick={props.handleNewConversation}>\n                ＋\n              </button>\n            </header>\n          )\n        }\n      }\n    </ChatAppContext.Consumer>\n  );\n}\n\nexport default SidebarBanner;","import React from 'react';\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport { Conversation } from '../../models/Conversation';\n\nimport \"./ConversationRow.css\"\n\ninterface ConversationRowProps extends RouteComponentProps {\n  selected: boolean,\n  conversation: Conversation,\n  handleConversationRowClick: (conversation: Conversation) => void,\n}\n\nfunction ConversationRow(props: ConversationRowProps) {\n  return (\n    <div\n      className={\"ConversationRow\" + (props.selected ? \" ConversationRow--selected\" : \"\")}\n      onClick={() => props.handleConversationRowClick(props.conversation)}>\n      <div className=\"ConversationRow__name\">\n        {props.conversation.conversationPartner.name\n          ?? props.conversation.conversationPartner.username}\n      </div>\n      <div className=\"ConversationRow__preview\"></div>\n    </div>\n  );\n}\n\nexport default ConversationRow;\n","import React from 'react';\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport ConversationRow from './ConversationRow';\nimport { Conversation } from '../../models/Conversation';\n\nimport \"./ConversationList.css\"\n\ninterface ConversationListProps extends RouteComponentProps {\n  conversations: Conversation[],\n  selectedConversation: Conversation | null,\n  handleConversationRowClick: (conversation: Conversation) => void,\n}\n\nfunction ConversationList(props: ConversationListProps) {\n  const conversationRows = props.conversations.map(conversation => {\n    return (\n      <ConversationRow\n        key={conversation.uuid}\n        selected={conversation.uuid === props.selectedConversation?.uuid}\n        conversation={conversation}\n        handleConversationRowClick={props.handleConversationRowClick} />\n    );\n  });\n  return (\n    <div className=\"ConversationList\">\n      {conversationRows}\n    </div>\n  );\n}\n\nexport default ConversationList;\n","import React from 'react';\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport SidebarBanner from './SidebarBanner';\nimport ConversationList from './ConversationList';\nimport { Conversation } from '../../models/Conversation';\n\nimport './Sidebar.css'\n\ninterface SidebarProps extends RouteComponentProps {\n  conversations: Conversation[],\n  selectedConversation: Conversation | null,\n  handleNewConversation: () => void,\n  handleConversationRowClick: (conversation: Conversation) => void,\n}\n\nfunction Sidebar(props: SidebarProps) {\n  return (\n    <nav className=\"Sidebar\">\n      <SidebarBanner handleNewConversation={props.handleNewConversation} />\n      <ConversationList\n        conversations={props.conversations}\n        selectedConversation={props.selectedConversation}\n        handleConversationRowClick={props.handleConversationRowClick} />\n    </nav>\n  );\n}\n\nexport default Sidebar;\n","import React from 'react'\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport { Conversation } from '../../models/Conversation';\n\nimport './ConversationViewBanner.css'\n\ninterface ConversationViewBannerProps extends RouteComponentProps {\n  selectedConversation: Conversation,\n}\n\ninterface ConversationViewBannerState {\n}\n\nfunction ConversationViewBanner(props: ConversationViewBannerProps) {\n  return (\n    <header className=\"ConversationViewBanner\" >\n      {props.selectedConversation.conversationPartner.name\n        ?? props.selectedConversation.conversationPartner.username}\n    </header >\n  );\n}\n\nexport default ConversationViewBanner;","import React from \"react\"\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport { ChatAppContext } from \"../ChatAppContext\";\nimport { Message } from \"../../models/Message\";\n\nimport './MessageView.css'\n\ninterface MessageViewProps extends RouteComponentProps {\n  message: Message,\n}\n\nfunction MessageView(props: MessageViewProps) {\n  return (\n    <ChatAppContext.Consumer>\n      {context =>\n        <div\n          className={\n            \"MessageView\"\n            + (context.user?.id === props.message.senderId\n              ? (props.message.id === null\n                ? \" MessageView--us_unsynced\"\n                : \" MessageView--us_synced\"\n              )\n              : \" MessageView--them\")\n          }>\n          <div className=\"MessageView__messageBody\">\n            {props.message.body}\n          </div>\n        </div >\n      }\n    </ChatAppContext.Consumer >\n  );\n}\n\nexport default MessageView;\n","import React from 'react';\n\nimport \"./LoadingIcon.css\";\n\ninterface LoadingIconProps {\n  width?: number,\n  height?: number,\n}\n\nfunction LoadingIcon(props: LoadingIconProps) {\n  const style = {\n    width: props.width ?? 40,\n    height: props.height ?? 40,\n  }\n  return (\n    <div className=\"LoadingIcon\" style={style}>\n    </div>\n  )\n}\n\nexport default LoadingIcon;","import React from 'react'\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport MessageView from './MessageView';\nimport { Message } from '../../models/Message';\nimport { ChatAppContext } from '../ChatAppContext';\n\nimport './MessagesView.css'\nimport LoadingIcon from '../../misc/LoadingIcon';\n\ninterface MessagesViewProps extends RouteComponentProps {\n  isLoading: boolean,\n  messages: Message[],\n}\n\ninterface MessagesViewState {\n}\n\ninterface MessagesViewSnapshot {\n  isScrolledToBottom: boolean,\n}\n\nclass MessagesView extends React.Component<MessagesViewProps, MessagesViewState> {\n  // Number of pixels chat div can be scrolled above bottom to still be considered at bottom\n  SCROLL_TOLERANCE = 40;\n\n  conversationViewDiv = React.createRef<HTMLDivElement>();\n\n  static contextType = ChatAppContext;\n  context!: React.ContextType<typeof ChatAppContext>\n\n  constructor(props: MessagesViewProps) {\n    super(props);\n    this.scrollToBottom = this.scrollToBottom.bind(this);\n  }\n\n  componentDidMount() {\n    this.scrollToBottom();\n  }\n\n  getSnapshotBeforeUpdate(prevProps: MessagesViewProps, prevState: MessagesViewState):\n    MessagesViewSnapshot {\n    return {\n      isScrolledToBottom: this.isScrolledToBottom()\n    };\n  }\n\n  render() {\n    let messages: JSX.Element[] = this.props.messages.map(message => {\n      return <MessageView key={message.uuid} message={message} />\n    });\n    return (\n      <div className=\"MessagesView\" ref={this.conversationViewDiv}>\n        {this.props.isLoading\n          && <div className=\"MessagesView__loadingIcon\"><LoadingIcon /></div>}\n        {messages}\n      </div>\n    );\n  }\n\n  componentDidUpdate(\n    prevProps: MessagesViewProps,\n    prevState: MessagesViewState,\n    snapshot: MessagesViewSnapshot,\n  ) {\n    const prevMessages = prevProps.messages;\n    const messages = this.props.messages;\n\n    // If there's a new message added\n    if (prevMessages[prevMessages.length - 1]?.uuid !== messages[messages.length - 1]?.uuid) {\n      // Keep us scrolled to the bottom if we're already there, or if the last message\n      // added is from us (i.e. we just sent a message).\n      if (snapshot.isScrolledToBottom\n        || messages[messages.length - 1].senderId === this.context.user.id) {\n        this.scrollToBottom();\n      }\n    }\n  }\n\n  private isScrolledToBottom(): boolean {\n    const node = this.conversationViewDiv.current;\n    if (node === null) {\n      return true;\n    }\n    return node.scrollTop >= (node.scrollHeight - node.clientHeight) - this.SCROLL_TOLERANCE;\n  }\n\n  private scrollToBottom() {\n    const node = this.conversationViewDiv.current;\n    if (node === null) {\n      return;\n    }\n    node.scrollTo(0, node.scrollHeight - node.clientHeight);\n  }\n}\n\nexport default MessagesView;\n","import React, { ChangeEvent, KeyboardEvent } from 'react'\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport './MessageInput.css'\n\ninterface MessageInputProps extends RouteComponentProps {\n  autoFocus: boolean,\n  disabled?: boolean,\n  handleSendMessage: (messageBody: string) => boolean,\n}\n\ninterface MessageInputState {\n  messageBody: string,\n}\n\nclass MessageInput extends React.Component<MessageInputProps, MessageInputState> {\n  state: MessageInputState = {\n    messageBody: \"\",\n  };\n\n  constructor(props: MessageInputProps) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.handleClickSend = this.handleClickSend.bind(this);\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n  }\n\n  handleChange(event: ChangeEvent<HTMLInputElement>) {\n    this.setState({\n      messageBody: event.target.value,\n    });\n  }\n\n  async handleClickSend() {\n    if (this.state.messageBody.trim() === \"\") {\n      return;\n    }\n    const success = this.props.handleSendMessage(this.state.messageBody);\n    if (success) {\n      this.setState({\n        messageBody: \"\",\n      });\n    }\n  }\n\n  handleKeyDown(event: KeyboardEvent<HTMLInputElement>) {\n    if (event.key === \"Enter\") {\n      this.handleClickSend();\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"MessageInput\" >\n        <input\n          name=\"messageBody\"\n          className=\"MessageInput__input\"\n          type=\"text\"\n          value={this.state.messageBody}\n          onKeyDown={this.handleKeyDown}\n          onChange={this.handleChange}\n          autoFocus={this.props.autoFocus}\n          placeholder=\"Type a message\" />\n        <button\n          className=\"MessageInput__button button\"\n          onClick={this.handleClickSend}\n          disabled={this.props.disabled}>\n          Send\n          </button>\n      </div>\n    );\n  }\n}\n\nexport default MessageInput;\n","import React from 'react';\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport { Conversation } from '../../models/Conversation';\nimport ConversationViewBanner from './ConversationViewBanner';\nimport MessagesView from './MessagesView';\nimport MessageInput from './MessageInput';\n\nimport './ConversationView.css'\n\ninterface ConversationViewProps extends RouteComponentProps {\n  selectedConversation: Conversation,\n  handleSendMessage: (messageBody: string) => void,\n}\n\nfunction ConversationView(props: ConversationViewProps) {\n  return (\n    <div className=\"ConversationView\" >\n      <ConversationViewBanner\n        selectedConversation={props.selectedConversation} />\n      <MessagesView\n        isLoading={props.selectedConversation.isLoading}\n        messages={props.selectedConversation.messages} />\n      <MessageInput\n        autoFocus={true}\n        handleSendMessage={\n          (messageBody) => {\n            props.handleSendMessage(messageBody);\n            return true;\n          }\n        } />\n    </div>\n  );\n}\n\nexport default ConversationView","import React, { ChangeEvent, FocusEvent } from 'react';\nimport LoadingIcon from '../../misc/LoadingIcon';\n\nimport './ConversationCreatorViewBanner.css'\n\nexport enum ConversationCreatorViewBannerStatus {\n  Empty,\n  Loading,\n  Ok,\n  Error,\n}\n\ninterface ConversationCreatorViewBannerProps {\n  conversationCreatorUsername: string,\n  status: ConversationCreatorViewBannerStatus,\n  handleChange: (event: ChangeEvent<HTMLInputElement>) => void,\n  handleBlur: (event: FocusEvent<HTMLInputElement>) => void,\n}\n\ninterface ConversationCreatorViewBannerState {\n}\n\nclass ConversationCreatorViewBanner extends\n  React.Component<ConversationCreatorViewBannerProps, ConversationCreatorViewBannerState> {\n  render() {\n    const toSpan =\n      <span className=\"ConversationCreatorViewBanner__to\">To:</span>\n\n    let status: JSX.Element;\n    switch (this.props.status) {\n      case ConversationCreatorViewBannerStatus.Empty:\n        status = toSpan;\n        break;\n      case ConversationCreatorViewBannerStatus.Error:\n        status = <span className=\"ConversationCreatorViewBanner__error\">✕</span>;\n        break;\n      case ConversationCreatorViewBannerStatus.Loading:\n        status = <LoadingIcon width={20} height={20} />;\n        break;\n      case ConversationCreatorViewBannerStatus.Ok:\n        status = <span className=\"ConversationCreatorViewBanner__success\">✔</span>;\n        break;\n    }\n    return (\n      <header className=\"ConversationCreatorViewBanner\">\n        <div className=\"ConversationCreatorViewBanner__status\">\n          <label\n            htmlFor=\"ConversationCreatorViewBannerInput\"\n            className=\"ConversationCreatorViewBanner__label\">\n            {status}\n          </label>\n        </div>\n        <input\n          type=\"text\"\n          className=\"ConversationCreatorViewBanner__input\"\n          placeholder=\"Username\"\n          value={this.props.conversationCreatorUsername}\n          autoFocus={true}\n          onChange={this.props.handleChange}\n          onBlur={this.props.handleBlur}\n          id=\"ConversationCreatorViewBannerInput\" />\n      </header>\n    );\n  }\n}\n\nexport default ConversationCreatorViewBanner;","import React, { ChangeEvent, FocusEvent } from 'react';\n\nimport ConversationCreatorViewBanner, { ConversationCreatorViewBannerStatus }\n  from './ConversationCreatorViewBanner';\nimport MessageInput from './MessageInput';\nimport { User } from '../../models/User';\nimport NchatApi from '../../utils/NchatApi';\nimport { ChatAppContext } from '../ChatAppContext';\nimport { UserJson } from '../../utils/json/UserJson';\n\nimport './ConversationCreatorView.css';\n\ninterface GetUserResponse {\n  user: UserJson,\n}\n\ninterface ConversationCreatorViewProps {\n  handleSendMessage: (messageBody: string, user?: User) => void,\n}\n\ninterface ConversationCreatorViewState {\n  username: string,\n  conversationPartner: User | null,\n  usernameInputStatus: ConversationCreatorViewBannerStatus,\n}\n\nclass ConversationCreatorView\n  extends React.Component<ConversationCreatorViewProps, ConversationCreatorViewState> {\n\n  static contextType = ChatAppContext;\n  context!: React.ContextType<typeof ChatAppContext>\n\n  state: ConversationCreatorViewState = {\n    username: \"\",\n    conversationPartner: null,\n    usernameInputStatus: ConversationCreatorViewBannerStatus.Empty,\n  }\n\n  constructor(props: ConversationCreatorViewProps) {\n    super(props);\n    this.handleUsernameChange = this.handleUsernameChange.bind(this);\n    this.handleSendMessage = this.handleSendMessage.bind(this);\n    this.handleUsernameInputBlur = this.handleUsernameInputBlur.bind(this);\n  }\n\n  handleUsernameChange(event: ChangeEvent<HTMLInputElement>) {\n    const username = event.target.value;\n    this.setState({\n      usernameInputStatus: ConversationCreatorViewBannerStatus.Empty,\n      username: username,\n    });\n  }\n\n  handleSendMessage(messageBody: string): boolean {\n    if (this.state.conversationPartner === null) {\n      return false;\n    }\n    this.props.handleSendMessage(messageBody, this.state.conversationPartner);\n    return true;\n  }\n\n  async handleUsernameInputBlur(event: FocusEvent<HTMLInputElement>) {\n    this.setState({\n      usernameInputStatus: ConversationCreatorViewBannerStatus.Loading,\n    });\n\n    const username = this.state.username;\n    if (username.trim() === \"\") {\n      this.setState({\n        usernameInputStatus: ConversationCreatorViewBannerStatus.Empty,\n      });\n      return;\n    }\n\n    try {\n      const user = await this.getConversationPartner(username);\n      this.setState({\n        conversationPartner: user,\n        usernameInputStatus: ConversationCreatorViewBannerStatus.Ok,\n      });\n    } catch (err) {\n      this.setState({\n        conversationPartner: null,\n        usernameInputStatus: ConversationCreatorViewBannerStatus.Error,\n      });\n    }\n  }\n\n  async getConversationPartner(username: string): Promise<User> {\n    const response =\n      await NchatApi.get<GetUserResponse>(\"users/\" + username, this.context.authKey);\n    const userJson = response.data.user;\n\n    return {\n      id: userJson.id,\n      username: userJson.username,\n      name: userJson.name,\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"ConversationCreatorView\">\n        <ConversationCreatorViewBanner\n          conversationCreatorUsername={this.state.username}\n          status={this.state.usernameInputStatus}\n          handleChange={this.handleUsernameChange}\n          handleBlur={this.handleUsernameInputBlur} />\n        <div className=\"ConversationCreatorView__spacer\" />\n        <MessageInput\n          autoFocus={false}\n          handleSendMessage={this.handleSendMessage}\n          disabled={this.state.usernameInputStatus !== ConversationCreatorViewBannerStatus.Ok} />\n      </div>\n    )\n  }\n}\n\nexport default ConversationCreatorView;","import React from 'react';\nimport { RouteComponentProps } from \"@reach/router\";\n\nimport { Conversation } from '../../models/Conversation';\nimport ConversationView from './ConversationView';\nimport ConversationCreatorView from './ConversationCreatorView';\nimport { User } from '../../models/User';\n\nimport \"./ContentView.css\"\n\ninterface ContentViewProps extends RouteComponentProps {\n  isConversationCreatorOpen: boolean,\n  selectedConversation: Conversation | null,\n  handleSendMessage: (messageBody: string, user?: User) => void,\n}\n\nfunction ContentView(props: ContentViewProps) {\n  return (\n    <main className=\"ContentView\" >\n      {\n        props.isConversationCreatorOpen\n          ?\n          <ConversationCreatorView\n            handleSendMessage={props.handleSendMessage} />\n          :\n          props.selectedConversation !== null\n          && <ConversationView\n            selectedConversation={props.selectedConversation}\n            handleSendMessage={props.handleSendMessage}\n            key={props.selectedConversation?.uuid} />\n      }\n    </main>\n  )\n}\n\nexport default ContentView;\n","import React from 'react';\nimport { RouteComponentProps } from '@reach/router';\nimport { v4 as uuidv4 } from 'uuid';\nimport update from 'immutability-helper';\n\nimport NchatApi from '../utils/NchatApi';\nimport Sidebar from './sidebar/Sidebar'\nimport ContentView from './contentView/ContentView'\nimport { User } from '../models/User';\nimport { Conversation } from '../models/Conversation';\nimport { Message } from '../models/Message';\nimport { ConversationJson } from '../utils/json/ConversationJson';\nimport { MessageJson } from '../utils/json/MessageJson';\nimport { ChatAppContext } from './ChatAppContext';\nimport NchatWebSocket, { WSNotification, WSRequest, WSSuccessResponse }\n  from '../utils/NchatWebSocket';\n\nimport './ChatApp.css';\n\ninterface GetConversationResponse {\n  conversation: ConversationJson,\n}\n\ninterface WSMessageNotificationData {\n  message: MessageJson,\n  conversation: ConversationJson,\n}\n\ninterface WSMessageRequestData {\n  username: string,\n  body: string,\n}\n\ninterface WSMessageSuccessResponseData {\n  message: MessageJson,\n  conversation: ConversationJson,\n}\n\ninterface WSMessageErrorResponseData {\n}\n\ninterface ChatAppProps extends RouteComponentProps {\n  authKey: string,\n  user: User,\n  conversations: Conversation[],\n  webSocket: NchatWebSocket,\n}\n\ninterface ChatAppState {\n  conversations: Conversation[],\n  selectedConversation: Conversation | null,\n  isConversationCreatorOpen: boolean,\n}\n\nclass ChatApp extends React.Component<ChatAppProps, ChatAppState> {\n  state: ChatAppState = {\n    conversations: this.props.conversations,\n    selectedConversation: null,\n    isConversationCreatorOpen: false,\n  }\n\n  constructor(props: ChatAppProps) {\n    super(props);\n    this.handleMessageReceived = this.handleMessageReceived.bind(this);\n    this.handleNewConversation = this.handleNewConversation.bind(this);\n    this.handleConversationRowClick = this.handleConversationRowClick.bind(this);\n    this.handleSendMessage = this.handleSendMessage.bind(this);\n  }\n\n  componentDidMount() {\n    this.props.webSocket.addNotificationListener(\"newMessage\", this.handleMessageReceived);\n  }\n\n  handleNewConversation() {\n    this.setState({\n      selectedConversation: null,\n      isConversationCreatorOpen: true,\n    });\n  }\n\n  async handleConversationRowClick(conversation: Conversation) {\n    if (conversation.uuid === this.state.selectedConversation?.uuid) {\n      return;\n    }\n\n    this.setState({\n      isConversationCreatorOpen: false,\n    });\n\n    if (!conversation.isHistoryLoaded && !conversation.isLoading) {\n      let index = this.state.conversations.findIndex(c => c.uuid === conversation.uuid);\n      const loadingConversations = update(this.state.conversations,\n        {\n          [index]: {\n            isLoading: {\n              $set: true,\n            },\n          },\n        },\n      );\n\n      this.setState({\n        conversations: loadingConversations,\n        selectedConversation: loadingConversations[index],\n      });\n\n      const response = await NchatApi.get<GetConversationResponse>(\n        \"conversations/\" + conversation.id, this.props.authKey);\n      const newMessages = response.data.conversation.messages.map(message => {\n        return {\n          uuid: uuidv4(),\n          id: message.id,\n          senderId: message.senderId,\n          body: message.body,\n          sent: message.sent,\n        }\n      });\n\n      index = this.state.conversations.findIndex(c => c.uuid === conversation.uuid);\n      const updatedConversations = update(this.state.conversations,\n        {\n          [index]: {\n            messages: {\n              $set: newMessages,\n            },\n            isLoading: {\n              $set: false,\n            },\n            isHistoryLoaded: {\n              $set: true,\n            }\n          }\n        },\n      );\n\n      this.setState({\n        conversations: updatedConversations,\n        selectedConversation: updatedConversations[index],\n      });\n    } else {\n      this.setState({\n        selectedConversation: conversation,\n      });\n    }\n  }\n\n  handleMessageReceived(notification: WSNotification<WSMessageNotificationData>) {\n    const messageJson = notification.data.message;\n    const conversationJson = notification.data.conversation;\n\n    const newMessage: Message = {\n      uuid: uuidv4(),\n      id: messageJson.id,\n      body: messageJson.body,\n      senderId: messageJson.senderId,\n      sent: messageJson.sent,\n    };\n\n    const index = this.state.conversations.findIndex(c => c.id === conversationJson.id);\n    if (index === -1) {\n      const newConversation: Conversation = {\n        uuid: uuidv4(),\n        id: conversationJson.id,\n        conversationPartner: {\n          id: conversationJson.conversationPartner.id,\n          username: conversationJson.conversationPartner.username,\n          name: conversationJson.conversationPartner.name,\n        },\n        messages: [newMessage],\n        isHistoryLoaded: true,\n        isLoading: false,\n      };\n      const updatedConversations = [\n        newConversation,\n        ...this.state.conversations,\n      ];\n      this.setState({\n        conversations: updatedConversations,\n      });\n    } else {\n      const updatedConversations = update(this.state.conversations,\n        {\n          [index]: {\n            messages: {\n              $push: [newMessage]\n            },\n          },\n        },\n      );\n      this.setState({\n        conversations: updatedConversations,\n      });\n      if (this.state.selectedConversation?.uuid === updatedConversations[index].uuid) {\n        this.setState({\n          selectedConversation: updatedConversations[index],\n        });\n      };\n    }\n  }\n\n  async handleSendMessage(messageBody: string, conversationPartner?: User) {\n    const newMessage: Message = {\n      uuid: uuidv4(),\n      id: null,\n      senderId: this.props.user.id,\n      body: messageBody,\n      sent: null,\n    }\n\n    let selectedConversation: Conversation | null;\n\n    if (this.state.isConversationCreatorOpen && conversationPartner) {\n      const newConversation: Conversation = {\n        uuid: uuidv4(),\n        id: null,\n        conversationPartner: conversationPartner,\n        isHistoryLoaded: true,\n        isLoading: false,\n        messages: [newMessage],\n      };\n\n      this.setState((state, props) => {\n        const updatedConversations = [\n          newConversation,\n          ...state.conversations,\n        ];\n        return {\n          conversations: updatedConversations,\n          selectedConversation: newConversation,\n          isConversationCreatorOpen: false,\n        };\n      });\n\n      selectedConversation = newConversation;\n    } else {\n      selectedConversation = this.state.selectedConversation;\n\n      if (selectedConversation === null) {\n        return;\n      }\n\n      const conversationIndex = this.state.conversations.findIndex(c => {\n        return c.uuid === selectedConversation?.uuid\n      });\n      const updatedConversations = update(this.state.conversations,\n        {\n          [conversationIndex]: {\n            messages: {\n              $push: [newMessage],\n            },\n          },\n        },\n      );\n\n      this.setState({\n        conversations: updatedConversations,\n        selectedConversation: updatedConversations[conversationIndex],\n      });\n    }\n\n    const response = await this.sendMessage(\n      selectedConversation.conversationPartner.username, messageBody);\n\n\n    this.setState((state, props) => {\n      const conversationIndex = state.conversations.findIndex(c => {\n        return c.uuid === selectedConversation?.uuid\n      });\n      const messageIndex = state.conversations[conversationIndex].messages.findIndex(m => {\n        return m.uuid === newMessage.uuid;\n      });\n\n      const syncedConversations = update(state.conversations,\n        {\n          [conversationIndex]: {\n            id: {\n              $set: response.data.conversation.id,\n            },\n            messages: {\n              [messageIndex]: {\n                id: {\n                  $set: response.data.message.id\n                },\n              },\n            },\n          },\n        },\n      );\n\n      return {\n        conversations: syncedConversations,\n        selectedConversation: syncedConversations[conversationIndex],\n      };\n    });\n  }\n\n  private sendMessage(username: string, body: string):\n    Promise<WSSuccessResponse<WSMessageSuccessResponseData>> {\n    const request: WSRequest<WSMessageRequestData> = {\n      type: \"request\",\n      method: \"sendMessage\",\n      data: {\n        username: username,\n        body: body,\n      },\n    };\n    return this.props.webSocket.sendRequest(request);\n  }\n\n  render() {\n    const contextValue = {\n      authKey: this.props.authKey,\n      user: this.props.user,\n    }\n    return (\n      <div className=\"ChatApp\">\n        <ChatAppContext.Provider value={contextValue}>\n          <Sidebar\n            conversations={this.state.conversations}\n            selectedConversation={this.state.selectedConversation}\n            handleConversationRowClick={this.handleConversationRowClick}\n            handleNewConversation={this.handleNewConversation} />\n          <ContentView\n            isConversationCreatorOpen={this.state.isConversationCreatorOpen}\n            handleSendMessage={this.handleSendMessage}\n            selectedConversation={this.state.selectedConversation} />\n        </ChatAppContext.Provider>\n      </div >\n    );\n  }\n\n  componentWillUnmount() {\n    this.props.webSocket.close();\n  }\n}\n\nexport default ChatApp;\n","export interface WSNotification<T> {\n  type: \"notification\",\n  method: string,\n  data: T,\n}\n\nexport interface WSRequest<T> {\n  id?: number,\n  type: \"request\",\n  method: string,\n  data: T,\n}\n\nexport interface WSSuccessResponse<T> {\n  id: number,\n  type: \"response\",\n  status: \"success\",\n  data: T,\n}\n\nexport interface WSErrorResponse<T> {\n  id: number,\n  type: \"response\",\n  status: \"error\",\n  code: number,\n  message: string,\n  data: T,\n}\n\ntype NotificationListener = (notification: WSNotification<any>) => void\ninterface NotificationListeners {\n  [index: string]: NotificationListener[]\n}\n\ntype PromiseResolveFunc = (value: WSSuccessResponse<any>) => void;\ntype PromiseRejectFunc = (reason: WSErrorResponse<any>) => void;\ntype PromiseCallbacks = {\n  resolve: PromiseResolveFunc,\n  reject: PromiseRejectFunc,\n}\n\nclass NchatWebSocket {\n  static websocketUrl = NchatWebSocket.getWebsocketUrl();\n\n  webSocket: WebSocket;\n  isAuthMessageSent = false;\n  requestId = 0;\n  requestPromises: PromiseCallbacks[] = [];\n  notificationListeners: NotificationListeners = {};\n\n  static getWebsocketUrl(): string {\n    let location = window.location;\n    let url = (location.protocol === \"https:\" ? \"wss:\" : \"ws:\");\n    url += \"//\" + location.host + \"/api/v1/chat\";\n    return url;\n  }\n\n  static createWebSocket(): Promise<NchatWebSocket> {\n    const webSocket = new WebSocket(this.websocketUrl, \"nchat\");\n    return new Promise((resolve, reject) => {\n      webSocket.addEventListener(\"open\", (event: Event) => {\n        const nchatWebSocket = new NchatWebSocket(webSocket);\n        resolve(nchatWebSocket);\n      })\n      webSocket.addEventListener(\"error\", (event: Event) => {\n        reject(event);\n      })\n    });\n  }\n\n  constructor(webSocket: WebSocket) {\n    this.handleMessageReceived = this.handleMessageReceived.bind(this);\n    this.webSocket = webSocket;\n    this.webSocket.addEventListener(\"message\", this.handleMessageReceived);\n  }\n\n  handleMessageReceived(event: MessageEvent) {\n    const data: WSNotification<any> | WSSuccessResponse<any> | WSErrorResponse<any> =\n      JSON.parse(event.data);\n    if (data.type === \"response\") {\n      if (data.status === \"success\") {\n        this.requestPromises[data.id].resolve(data);\n      } else {\n        this.requestPromises[data.id].reject(data);\n      }\n    } else if (data.type === \"notification\") {\n      const listeners = this.notificationListeners[data.method];\n      if (typeof listeners !== \"undefined\") {\n        for (const listener of listeners) {\n          listener(data);\n        }\n      }\n    }\n  }\n\n  addNotificationListener(method: string, listener: (notification: WSNotification<any>) => void) {\n    if (this.notificationListeners.hasOwnProperty(method)) {\n      this.notificationListeners[method]?.push(listener);\n    } else {\n      this.notificationListeners[method] = [listener];\n    }\n  }\n\n  sendRequest<T, S>(request: WSRequest<T>):\n    Promise<WSSuccessResponse<S>> {\n    const id = this.getNextId();\n    request.id = id;\n\n    this.webSocket.send(JSON.stringify(request));\n\n    return new Promise((resolve, reject) => {\n      this.registerPromise(id, resolve, reject);\n    });\n  }\n\n  close() {\n    this.webSocket.close();\n  }\n\n  private registerPromise(id: number, resolve: PromiseResolveFunc, reject: PromiseRejectFunc) {\n    this.requestPromises[id] = {\n      resolve: resolve,\n      reject: reject\n    };\n  }\n\n  private getNextId(): number {\n    return this.requestId++;\n  }\n}\n\nexport default NchatWebSocket;","import React from 'react';\nimport { RouteComponentProps } from '@reach/router';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport ChatApp from './ChatApp';\nimport { Conversation } from '../models/Conversation';\nimport { ConversationStubJson } from '../utils/json/ConversationJson';\nimport { User } from '../models/User';\nimport { UserJson } from '../utils/json/UserJson';\nimport NchatApi from '../utils/NchatApi';\nimport NchatWebSocket, { WSRequest, WSSuccessResponse } from '../utils/NchatWebSocket';\n\nimport \"./ChatAppLoader.css\";\nimport LoadingIcon from '../misc/LoadingIcon';\n\ninterface GetAuthenticateResponse {\n  user: UserJson,\n}\n\ninterface GetConversationsResponse {\n  conversations: ConversationStubJson[];\n}\n\ninterface WSAuthRequestData {\n  authKey: string,\n}\n\ninterface WSAuthResponseData {\n}\n\ninterface ChatAppLoaderProps extends RouteComponentProps {\n  authKey: string,\n  user: User | null,\n}\n\ninterface ChatAppLoaderState {\n  user: User | null,\n  conversations: Conversation[] | null,\n  webSocket: NchatWebSocket | null,\n}\n\nclass ChatAppLoader extends React.Component<ChatAppLoaderProps, ChatAppLoaderState> {\n  state: ChatAppLoaderState = {\n    user: this.props.user,\n    conversations: null,\n    webSocket: null,\n  }\n\n  async componentDidMount() {\n    const userPromise = this.state.user === null\n      ? Promise.resolve(this.state.user)\n      : this.initUser();\n    const conversationsPromise = this.initConversations();\n\n    const webSocket = await NchatWebSocket.createWebSocket();\n    const authResponse = await this.sendAuth(webSocket);\n    if (authResponse.status !== \"success\") {\n      throw new Error(\"Could not connect to webSocket.\")\n    }\n\n    const [user, conversations] = await Promise.all([userPromise, conversationsPromise]);\n\n    this.setState({\n      user: user,\n      conversations: conversations,\n      webSocket: webSocket,\n    })\n  }\n\n  async initUser(): Promise<User> {\n    const response =\n      await NchatApi.get<GetAuthenticateResponse>(\"authenticate\", this.props.authKey);\n    const user: User = {\n      id: response.data.user.id,\n      name: response.data.user.name,\n      username: response.data.user.username,\n    }\n    return user;\n  }\n\n  async initConversations(): Promise<Conversation[]> {\n    const response =\n      await NchatApi.get<GetConversationsResponse>(\"conversations\", this.props.authKey);\n\n    const conversations = response.data.conversations.map(conversation => {\n      return {\n        uuid: uuidv4(),\n        id: conversation.id,\n        conversationPartner: {\n          id: conversation.conversationPartner.id,\n          username: conversation.conversationPartner.username,\n          name: conversation.conversationPartner.name,\n        },\n        messages: [],\n        isHistoryLoaded: false,\n        isLoading: false,\n      };\n    });\n    return conversations;\n  }\n\n  private sendAuth(webSocket: NchatWebSocket):\n    Promise<WSSuccessResponse<WSAuthResponseData>> {\n    const request: WSRequest<WSAuthRequestData> = {\n      type: \"request\",\n      method: \"authorize\",\n      data: {\n        authKey: this.props.authKey,\n      },\n    };\n\n    return webSocket.sendRequest(request);\n  }\n\n  render() {\n    return (\n      <div className=\"ChatAppLoader\">\n        {\n          this.state.user && this.state.conversations && this.state.webSocket\n            ?\n            <ChatApp\n              authKey={this.props.authKey}\n              user={this.state.user}\n              webSocket={this.state.webSocket}\n              conversations={this.state.conversations} />\n            :\n            <div className=\"ChatAppLoader__loading\">\n              <LoadingIcon />\n            </div>\n        }\n      </div>\n    );\n  }\n}\n\nexport default ChatAppLoader","import React, { ChangeEvent, FormEvent } from 'react';\nimport { RouteComponentProps } from '@reach/router';\nimport { Link } from \"@reach/router\";\n\nimport './LoginForm.css';\n\ninterface LoginFormProps extends RouteComponentProps {\n  authenticateUser: (username: string, password: string) => void,\n};\n\ninterface LoginFormState {\n  username: string,\n  password: string,\n}\n\nclass LoginForm extends React.Component<LoginFormProps, LoginFormState> {\n  state: LoginFormState = {\n    username: '',\n    password: '',\n  };\n\n  constructor(props: LoginFormProps) {\n    super(props);\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event: ChangeEvent<HTMLInputElement>) {\n    this.setState({\n      [event.target.name]: event.target.value,\n    } as Pick<LoginFormState, keyof LoginFormState>);\n  }\n\n  async handleSubmit(event: FormEvent<HTMLFormElement>) {\n    event.preventDefault();\n\n    this.props.authenticateUser(this.state.username, this.state.password);\n  }\n\n  render() {\n    return (\n      <div className=\"LoginForm\" >\n        <h1>Login</h1>\n        <form onSubmit={this.handleSubmit}>\n          <p><input className=\"textInput\" name=\"username\" type=\"text\" placeholder=\"Username\"\n            value={this.state.username} onChange={this.handleChange} required={true}\n            autoFocus={true} /></p>\n          <p><input className=\"textInput\" name=\"password\" type=\"password\" placeholder=\"Password\"\n            value={this.state.password} onChange={this.handleChange} required={true} /></p>\n          <p><input className=\"button\" type=\"submit\" value=\"Login\" /></p>\n        </form>\n        <div className=\"LoginForm__signUpMessage\">\n          Don't have an account? <Link to=\"../signup\">Sign up</Link>\n        </div>\n      </div >\n    );\n  }\n}\n\nexport default LoginForm;\n","import React, { ChangeEvent, FormEvent } from 'react';\nimport { RouteComponentProps } from '@reach/router';\nimport { Link } from \"@reach/router\";\n\nimport NchatApi from '../utils/NchatApi';\n\nimport './SignUpForm.css';\n\ninterface SignUpFormProps extends RouteComponentProps {\n  authenticateUser: (username: string, password: string) => void,\n};\n\ninterface SignUpFormState {\n  name: string,\n  username: string,\n  password: string,\n}\n\nclass SignUpForm extends React.Component<SignUpFormProps, SignUpFormState> {\n  state: SignUpFormState = {\n    \"name\": \"\",\n    \"username\": \"\",\n    \"password\": \"\",\n  };\n\n  constructor(props: SignUpFormProps) {\n    super(props);\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event: ChangeEvent<HTMLInputElement>) {\n    this.setState({\n      [event.target.name]: event.target.value,\n    } as Pick<SignUpFormState, keyof SignUpFormState>)\n  }\n\n  async handleSubmit(event: FormEvent<HTMLFormElement>) {\n    event.preventDefault();\n\n    const requestBody = {\n      \"name\": this.state.name,\n      \"username\": this.state.username,\n      \"password\": this.state.password,\n    }\n\n    // try {\n    const response = await NchatApi.post(\"users\", requestBody);\n    this.props.authenticateUser(this.state.username, this.state.password);\n\n    // } catch (error) {\n    //   throw error;\n    // }\n  }\n\n  render() {\n    return (\n      <div className=\"SignUpForm\" >\n        <h1>Sign up</h1>\n        <form onSubmit={this.handleSubmit}>\n          <p><input className=\"textInput\" name=\"name\" type=\"text\" placeholder=\"Display name\"\n            value={this.state.name} onChange={this.handleChange} required={true}\n            autoFocus={true} /></p>\n          <p><input className=\"textInput\" name=\"username\" type=\"text\" placeholder=\"Username\"\n            value={this.state.username} onChange={this.handleChange} required={true} /></p>\n          <p><input className=\"textInput\" name=\"password\" type=\"password\" placeholder=\"Password\"\n            value={this.state.password} onChange={this.handleChange} required={true} /></p>\n          <p><input className=\"button\" type=\"submit\" value=\"Sign up\" /></p>\n        </form>\n        <div className=\"SignUpForm__loginMessage\">\n          Already have an account? <Link to=\"../login\">Login</Link>\n        </div>\n      </div >\n    );\n  }\n}\n\nexport default SignUpForm;\n","import React from 'react';\nimport { RouteComponentProps } from '@reach/router';\nimport { Router, navigate } from \"@reach/router\";\n\nimport LoginForm from './LoginForm';\nimport SignUpForm from './SignUpForm';\nimport NchatApi from '../utils/NchatApi';\nimport { UserJson } from '../utils/json/UserJson';\n\nimport './AccountsView.css'\nimport { User } from '../models/User';\n\ninterface AccountsViewProps extends RouteComponentProps {\n  setAuthenticatedUser: (authKey: string, user: User) => void;\n}\n\ninterface AccountsViewState {\n}\n\ninterface PostAuthenticateResponse {\n  authKey: string,\n  user: UserJson,\n}\n\nclass AccountsView extends React.Component<AccountsViewProps, AccountsViewState> {\n  constructor(props: AccountsViewProps) {\n    super(props);\n\n    this.authenticateUser = this.authenticateUser.bind(this);\n  }\n\n  async authenticateUser(username: string, password: string) {\n    const requestBody = {\n      \"username\": username,\n      \"password\": password,\n    }\n\n    // try {\n    const response = await NchatApi.post<PostAuthenticateResponse>(\"authenticate\", requestBody);\n\n    const authKey = response.data.authKey;\n    const user: User = {\n      id: response.data.user.id,\n      username: response.data.user.username,\n      name: response.data.user.name,\n    }\n    this.props.setAuthenticatedUser(authKey, user);\n    // } catch (error) {\n    //   throw error;\n    // }\n    navigate(\"/\");\n  }\n\n  render() {\n    return (\n      <main className=\"AccountsView\">\n        <Router>\n          <LoginForm path=\"login\" authenticateUser={this.authenticateUser} />\n          <SignUpForm path=\"signup\" authenticateUser={this.authenticateUser} />\n        </Router>\n      </main>\n    );\n  }\n}\n\nexport default AccountsView;","import React from 'react';\nimport { Router, RouteComponentProps, navigate } from \"@reach/router\";\n\nimport ChatAppLoader from './chatApp/ChatAppLoader';\nimport AccountsView from './accounts/AccountsView';\nimport { User } from './models/User'\n\nimport './App.css';\n\ninterface AppState {\n  authKey: string | null,\n  user: User | null,\n}\n\nclass App extends React.Component<{}, AppState> {\n  state: AppState = {\n    authKey: null,\n    user: null,\n  };\n\n  constructor(props: RouteComponentProps) {\n    super(props);\n\n    this.setAuthenticatedUser = this.setAuthenticatedUser.bind(this);\n  }\n\n  componentDidMount() {\n    if (this.state.authKey === null) {\n      navigate('/accounts/login');\n    }\n  }\n\n  setAuthenticatedUser(authKey: string, user: User) {\n    this.setState({\n      \"authKey\": authKey,\n      \"user\": user,\n    })\n  }\n\n  render() {\n    return (\n      <Router className=\"Router\">\n        {this.state.authKey !== null &&\n          <ChatAppLoader path=\"/\"\n            authKey={this.state.authKey}\n            user={this.state.user}\n            key={this.state.user?.id} />}\n        <AccountsView path=\"accounts/*\" setAuthenticatedUser={this.setAuthenticatedUser} />\n      </Router >\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './common.css';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}